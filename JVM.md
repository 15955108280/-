# jvm虚拟机

### 主要包括

1. **程序计数器**：当前线程的字节码指示器，线程私有：保证各个线程之间独立运行。
2. **Java虚拟机栈**：线程私有，生命周期与线程相同，用于存储局部变量表（编译器可知的基础类型数据，reference），操作数栈，动态链表，方法出入口，方法的执行过程对应栈帧的出入栈。
3. **本地方法栈**：执行native方法，与虚拟机栈相似有的虚拟机都没有（HotSpot）。
4. **java堆**：存储对象，线程共享，垃圾收集的主要区域。
5. **方法区：** 存储已被虚拟机加载的类的信息，常量，静态变量，即时编译后的代码数据。
   - 运行时常量池：存放编译期生成的各种字面量和符号引用。

### HotSpot对象

##### 对象的创建

1. new指令
2. 能否在常量池中定位到一个类的符号引用
3. 此符号引用代表的类是否已经被解析初始化过
4. 若是没有则必须执行类的加载过程
5. 为新生对象分配内存→虚拟机将非陪到的空间值初始化为零值（除对象头）
6. 对对象进行必要的设值
7. 执行init方法

##### 对象的内存布局

1. **对象头：** 运行时数据（哈希码，gc年龄分代，锁状态标志，线程持有的锁，偏向线程ID等），类型指针即对象指向它的类的元数据的指针，通过该指针确定是哪个类的实例。
2. **实例数据：** 对象真正存储的有效信息（无论是子类定义的还是父类继承下来）
3. **对齐填充：** 占位符作用

##### 对象的方位定位

1. 通过句柄池

![1566195327764](C:\Users\YXP\AppData\Roaming\Typora\typora-user-images\1566195327764.png)

1. 通过指针直接访问

![1566195341354](C:\Users\YXP\AppData\Roaming\Typora\typora-user-images\1566195341354.png)

### 垃圾收集器和内存分配策略

#### 对象已死么

##### 引用计数法

​	给对象添加一个引用计数器，引用一次+1，引用失效-1。无法解决对象间的互相引用。

##### 可达性分析法

​	GC Roots作为对象的起始点，往下搜索（所走过的路径成为引用链），当一个对象到GC Roots没用引用链的时候镇宫这个对象是不可达的。

​	可作为GC Roots的对象：

- 虚拟机栈中引用的对象
- 方法去中静态属性引用过的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI引用的对象

###### 引用

1. **强引用：** Object obj=new Object（）只要引用还在垃圾收集器永远不会回收引用的对象。
2. **软引用：** 还有用但并非必需的对象，系统发生内存溢出之前进行第二次回收。
3. **弱引用：** 非必需对象，只能生存到下一次垃圾手机发生之前。
4. **虚引用：** 对其生存时间不够成影响

##### 生存还是死亡

​	即使是不可达对象也并不是必死，还需要判断是否有必要执行finalize（）方法（没有覆盖finalize方法或finalize方法已经被虚拟机调用过是为没有必要执行）。若是有必要只需要在F-Queue队列执行过程中与引用链中任一对象建立关联姐拯救自己。

##### 回收方法区（永久代）

1. **废弃常量：** 如没有任何一个String对像引用“abc”则“abc"会被清出常量池
2. **无用的类：** 
   - 该类中所有的实例都已经被回收
   - 加载该类的ClassLoader已经被回收
   - 该类对应的java.lang.Class对象没有在任何地方被引用

#### 垃圾收集算法

##### 标记-清除算法

​	标记出所有需要回收的对象，然后统一回收所有被标记的对象。

缺点：

- 效率低
- 产生大量的不连续内存碎片

##### 复制算法

​	将内存按容量划分为两块，将存活的对象复制到另一块，然后同一清理掉刚刚那一块

优点：

- 不用考虑内存空间的碎片复杂度，实现简单运行高效

缺点：

- 可用内存缩小为原来的一半

##### 标记-整理算法

​	标记过后将所有存活的对象都向一端移动，清除端边界以外的内存。

##### 分代收集法

​	根据存活周期将内存划分为几块，根据各自的年代采用最为适合的收集算法。

#### HotSpot的算法实现

##### 安全点

​	使用一组称为OopMap的数据结构记录GC Roots，类加载完成之后，HotSpot会把对象偏移量与类型计算出来，这样可一在GC扫描的扫描的时候直接得到这些信息。程序执行的时候只有在安全点（safepoint）生成OopMap。

- 抢先式中断：GC发生的时候停掉所有线程，若是有线程不在安全点上则继续执行至安全点。
- 主动中断：在安全点设置轮询标志，线程执行过程中主动去轮询这个标志，发现标志为真的时中断挂起。

##### 安全区域

​	当线程处于中断或者挂起状态则无法进入安全点，安全区是指在一段代码中引用关系保护会发生变化，即这个区域的任何地方都是GC安全的。

​	在线程执行到安全区时标记自己，若是这段时间内发起GC可不用管在安全区内的线程，该线程只可以在GC完成了根节点枚举才可离开安全区。

##### 垃圾收集器-新生代

**Serial** 

​	单线程收集器，使用复制算法，在工作的时候必须暂停所有的工作线程，直至它收集结束。

**ParNew**

​	Serial的多线程版本，使用复制算法，只有它可以和CMS合作。

**Parallel Scavenge**

​	并行多项成收集器，使用复制算法，关注点在于尽可能的提高吞吐量（运行用户代码的时间/（运行代码的时间+来及收集的时间））。

- MaxGCPauseMillis(最大垃圾收集停顿时间)，调小会牺牲新生代的空间和吞吐量。
- GCTimeRatio(吞吐量大小)，0<GCTimeRatio<100,垃圾收集时间占总时间的比率。

###### 垃圾收集器-老年代

**Serial Old**

​	Serial收集器的老年代的版本，标记整理算法。

**Parallel Old**

​	Parallel Scavenge的老年代版本，使用标记整理算法，多线程。

**CMS**

​	以获取最短会后停顿时间为目标的收集器，使用标记清除算法，整个过程分为4个步骤：

- 初始标记（CMS initial mark）:标记GC Roots直接关联的对象，速度速度快。会发生stop the world

- 并发标记（CMS concurrent mark）:GC RootsTracing过程

- 重新标记（CMS remark）：修正并发标记阶段继续运作产生的对象标记变化

- 并发清除（CMS concrrent sweep）

  其中最长时间的并发标记和并发清除都可以与用户线程一起执行工作。

缺点：

- 并发阶段虽然不会导致线程停止但是会暂用cpu资源
- 无法处理浮动垃圾（标记过程后出现的垃圾）
- 基于标记清除算法，会有大量的碎片空间

**GI**

​	是一款面向服务端的垃圾收集器。

特点：

- 并行并发
- 分代收集
- 空间整合
- 可预测停顿

#### 对象内存分配

- 对象有限分配在Eden区中
- 大对象直接分配在老年代
- 长期存活的对象将进入老年代：对象经历一次Minor GChou 仍存活，兵器能被Survivor容纳，年龄计数器（Age）设为1，在Survivor总每熬过Minor GC就+1，达到15即可晋升到老年代。
- 若是Survivor所有某一年龄的对象占空间的一般以上，该年龄以及大于该年龄的对象直接进入老年代

###### 空间分配担保

新生代采用复制收集算法，但是只有一个Survivor空间作为轮换北非，到Survivor满了之后就需要将其无法容纳的队形直接进入老年代，就需要老年代进行空间担保。

